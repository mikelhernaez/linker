AMARETTO_LarsenBased_soft_linc <- function(Data,Clusters,RegulatorData,Parameters,NrCores){
  # this will register nr of cores/threads, keep this here so the user can decide how many cores based on their hardware.
  registerDoParallel(cores=NrCores)
  ptm1 <- proc.time()
  
  MAX_EM_ITERATIONS<- 100
  
  RegulatorData_rownames=rownames(RegulatorData)
  Data_rownames=rownames(Data)
  
  Lambda = Parameters$Lambda2
  
  # main loop
  jj<-1
 
  NrClusters = length(unique(Clusters))
  NrSamples<-dim(Data)[2]
  NrGenes<-dim(Data)[1]
  
  Weights<-matrix(0,nrow=NrClusters, ncol=NrGenes)
  
  #Initialize module parameters using the k-means results (M step)
  #module_means<-matrix(0,nrow=NrClusters, ncol=NrSamples)
  #module_cov<-list()
  #module_priors<-numeric()
  
  module_means<-numeric()
  module_var<-numeric()
  module_priors<-numeric()
  
  Data_reduced<-apply(Data,1, median)
  
  for(i in 1:NrClusters){
    module_data_reduced<-Data_reduced[which(Clusters == i)]

    # I am summarizing the samples by the median
    module_means[i]<-mean(module_data_reduced)
    module_var[i]<-var(module_data_reduced)
    
    #module_means[i,]<-apply(module_data,2,mean)
    #module_cov[[i]]<-cov(module_data, module_data, use="all.obs")
    
    module_priors[i]<-length(module_data_reduced)/length(Clusters)
  }
  
  while (jj < MAX_EM_ITERATIONS){
    
    #E Step: Compute the weights: Expected value of being generated by each module
    ptm <- proc.time()
    for(gene_idx in 1: NrGenes){
      for(module_idx in 1: NrClusters){
        #Weights[module_idx, gene_idx]<-dmvnorm(Data[gene_idx,], module_means[module_idx,], module_cov[[module_idx]], log = FALSE) * module_priors[module_idx]
        #Using a 1d gaussian for each module
        Weights[module_idx, gene_idx]<-dnorm(Data_reduced[gene_idx], module_means[module_idx], module_var[module_idx], log = FALSE) * module_priors[module_idx]
      }
      Weights[,gene_idx]<-Weights[,gene_idx]/sum(Weights[,gene_idx])
    }
    print(apply(Weights, 1, sum))
    
    #STEP LINCRNA:  learning the regulatory program for each cluster
    ptm <- proc.time()
    switch(Parameters$Mode,
           larsen={
             regulatoryPrograms <- AMARETTO_LearnRegulatoryProgramsLarsen_soft_linc(Data,Weights,RegulatorData,RegulatorSign,Lambda,AutoRegulation,alpha=Parameters$alpha,pmax=Parameters$pmax)
           }
    )
    ptm <- proc.time() - ptm
    printf("Elapsed time is %f seconds\n",ptm[3])
    
    
    sum = 0
    for(i in 1:NrClusters){
      sum = sum + Matrix::nnzero(regulatoryPrograms$Beta[i,] )
    }
    avg = sum / NrClusters
    
    printf("Average nr of regulators per module: %f \n",avg)
    
    
    ptm <- proc.time() - ptm
    printf("Elapsed time at iteration %d is %f seconds\n",jj, ptm[3])
    jj<-jj+1
    
    #M Step: Compute the ML parameters from of the weights and the regulatory programs
    for(i in 1:NrClusters){
      
      module_means[i]<-median(regulatoryPrograms$centroids[i,])
      module_var[i]<- 1/sum(Weights[i,]) * sum(Weights[i,]*(Data_reduced-module_means[i])^2)
      module_priors[i]<-sum(Weights[i,])/NrGenes
    }
    
  }
  ptm1<- proc.time() - ptm1
  printf("Elapsed time  is %f seconds\n\n",ptm1[3])
  
  # update results structure
  ModuleMembership=as.matrix(PreviousClusters)
  rownames(ModuleMembership)=rownames(Data)
  colnames(ModuleMembership)=c("ModuleNr")
  
  result <- list(NrModules = length(unique(Clusters)),RegulatoryPrograms = regulatoryPrograms$Beta,AllRegulators=rownames(RegulatorData),
                 AllGenes = rownames(Data),ModuleMembership = ModuleMembership,AutoRegulationReport=regulatoryPrograms$AutoRegulationReport)
  
  return(result)
}





AMARETTO_LearnRegulatoryProgramsLarsen_soft_linc<-function(Data,Weights,RegulatorData,RegulatorSign,Lambda,AutoRegulation,alpha,pmax){
  
  RegulatorData_rownames=rownames(RegulatorData)
  Data_rownames=rownames(Data)
  
  # stop has to be set because otherwise the algorithm continues until every
  # var is entered into the model
  #pmax = -10 # maximum nr of regulators that you want
  trace = 0
  NrFolds = 10
  NrClusters = dim(Weights)[1]
  NrGenes = nrow(Data)
  NrSamples = ncol(Data)
  NrInterpolateSteps = 100
  
  # autoregulation yes or no?
  #if (AutoRegulation >= 1){
    #Beta = mat.or.vec((NrClusters),length(RegulatorData_rownames))
  #} else if (AutoRegulation == 0) {
  #  BetaSpecial = list(NrClusters,1)
  #  RegulatorPositions = list(NrClusters,1)
  #}
  #AutoRegulationReport = mat.or.vec(NrClusters,3)
  
  Beta = mat.or.vec((NrClusters),length(RegulatorData_rownames))
  y_all = mat.or.vec(NrClusters,NrSamples)
  y_std = numeric(NrClusters)
  intercept<-numeric(NrClusters)
  
  #ClusterIDs = unique(Clusters)
  #ClusterIDs = sort(ClusterIDs, decreasing = FALSE)
  #cnt <- 1:NrClusters
  
  ptm1 <- proc.time()
  #BetaY_all <- foreach(i=1:NrClusters,.combine=cbind,.init=list(list(),list(),list()),.packages = "glmnet") %dopar% {
    for (i in 1:NrClusters){
    
    #for each module, compute the mean:
    y = 1/sum(Weights[i,]) * (t(Data) %*% Weights[i,])
    #CurrentClusterPositions = which(Clusters %in% ClusterIDs[i])
    #nrGenesInClusters = length(CurrentClusterPositions)
    if(var(y)<1e-5){
      print("hello")
    }
    #if (AutoRegulation >= 1){
      X = RegulatorData
    #} else if (AutoRegulation == 0){
    #  X = RegulatorData[setdiff(RegulatorData_rownames,Data_rownames[CurrentClusterPositions]),]
    #}
    
    fit = cv.glmnet(t(X), y,alpha = alpha, pmax = pmax)
    
    nonZeroLambdas <- fit$lambda[which(fit$nzero>0)]
    nonZeroCVMs <- fit$cvm[which(fit$nzero>0)]
    
    if(length(which(nonZeroCVMs==min(nonZeroCVMs,na.rm=TRUE)))==0){
      
      #for now: just print a warning, *although* this error WILL cause Amaretto to crash in a few steps.
      warnMessage <- paste0("\nOn cluster ",i," there were no cv.glm results that gave non-zero coefficients.")
      warning(warnMessage);
      
    }
    
    bestNonZeroLambda <- nonZeroLambdas[which(nonZeroCVMs==min(nonZeroCVMs,na.rm=TRUE))]
    b_o = coef(fit,s = bestNonZeroLambda)
    b_opt <- c(b_o[2:length(b_o)]) # removing the intercept.
    
    ###### XXX: TODO autoregulation, no needed for lncRNAs ########
    # if (AutoRegulation == 2){ # autoregulation is allowed, if the regulator is stable also after removing it from the its regulated cluster.
    #   
    #   CurrentUsedRegulators = RegulatorData_rownames[which(b_opt!=0, arr.ind = T)]
    #   CurrentClusterMembers = Data_rownames[CurrentClusterPositions]
    #   nrIterations = 0 # 0 means no overlap initially
    #   while (length(CurrentClusterMembers[CurrentClusterMembers %in% CurrentUsedRegulators]) != 0){
    #     # keeping track of the removed Cluster Members:
    #     CurrentClusterMembers = setdiff(CurrentClusterMembers,CurrentUsedRegulators)  #problem here if the current cluster is empty
    #     nrCurrentClusterMembers = length(CurrentClusterMembers)
    #     
    #     if (nrCurrentClusterMembers > 0){
    #       names = Data_rownames %in% CurrentClusterMembers
    #       if (length(which(names==TRUE))>1){
    #         y = apply((Data[names,]),2,mean) # only removing the used regulators from
    #       } else {
    #         y = Data[names,]
    #       }
    #       
    #       fit = cv.glmnet(t(X), y,alpha = alpha, pmax = pmax)
    #       nonZeroLambdas <- fit$lambda[which(fit$nzero>0)]
    #       nonZeroCVMs <- fit$cvm[which(fit$nzero>0)]
    #       
    #       if(length(which(nonZeroCVMs==min(nonZeroCVMs,na.rm=TRUE)))==0){
    #         
    #         #for now: just print a warning, *although* this error WILL cause Amaretto to crash in a few steps.
    #         warnMessage <- paste0("\nOn cluster ",i," there were no cv.glm results that gave non-zero coefficients during the Autoregulation step.")
    #         warning(warnMessage);
    #         
    #       }
    #       
    #       bestNonZeroLambda <- nonZeroLambdas[which(nonZeroCVMs==min(nonZeroCVMs,na.rm=TRUE))]
    #       new_b_o = coef(fit,s = bestNonZeroLambda)
    #       #what was used up until 09/09/2014 instead of bestNonZeroLambda:
    #       #new_b_o = coef(fit,s = fit$lambda.1se)
    #       new_b_opt <- c(new_b_o[2:length(b_o)])
    #       
    #       CurrentUsedRegulators = RegulatorData_rownames[which(new_b_opt != 0)]
    #       nrIterations = nrIterations + 1
    #       b_opt = new_b_opt
    #     } else{
    #       # no more cluster members left, the cluster is empty.
    #       b_opt = rep(0,length(RegulatorData_rownames))
    #     }
    #   }
    #   Report <- c(length(CurrentClusterPositions),length(CurrentClusterMembers),nrIterations)
    #   
    #   #Report(1)=length(CurrentClusterPositions) #original clusters members
    #   #Report(2)=length(CurrentClusterMembers) #eventual nr of cluster members after removing members that were selected as regulator
    #   #Report(3)=nrIterations
    #   #AutoRegulationReport[i,]=t(Report)
    #   #AutoRegulationReport=Report
    # }
    
    # need to do this after the autoregulation, otherwise autoregulation
    # can still add positive microRNA regulators
    # if (sum(RegulatorSign[which(RegulatorSign != 0)]) > 0){ # there are limitations on the sign of the regulators
    #   RegulatorCheck = RegulatorSign * t(b_opt)
    #   WrongRegulators = which(RegulatorCheck < 0)
    #   if (length(WrongRegulators)  == 0){# just remove the wrong regulators
    #     b_opt[WrongRegulators] = 0
    #   }
    # }
    
    #if (AutoRegulation >= 1){
      #Beta[i,] = b_opt
    #} else {
    #  BetaSpecial[i] = b_opt
    #  RegulatorPositions[i] = (RegulatorData_rownames %in% setdiff(RegulatorData_rownames,Data_rownames[CurrentClusterPositions])) # keeping track of the regulators' positions
    #}
    
    ####y_all[i,] = y
    #list(b_opt,y,Report, y_std)
    list(b_opt,y, y_std)
    
    Beta[i,]<-b_opt
    y_all[i,] = y
    intercept[i]<-b_o[1]
    
  }
  
  ###ptm1<- proc.time() - ptm1
  ###printf("Elapsed time is %f seconds\n",ptm1[3])
  #if (AutoRegulation == 0){
  #  for (i in 1:NrClusters){
  #    Beta[i,RegulatorPositions[i]] = BetaSpecial[i]
  #  }
  #}
  
  tmpPos=NrClusters+1
  
  #Beta <- do.call(cbind, BetaY_all[1,2:tmpPos])
  #Beta = t(Beta);
  colnames(Beta)=RegulatorData_rownames
  rownames(Beta)=gsub('result.','Module_',rownames(Beta))
  
  #y_all<-do.call(cbind, BetaY_all[2,2:tmpPos])
  #y_all = t(y_all);
  rownames(y_all)=gsub('result.','Module_',rownames(y_all))
  
  #AutoRegulationReport<-do.call(cbind, BetaY_all[3,2:tmpPos])
  #AutoRegulationReport = t(AutoRegulationReport)
  #rownames(AutoRegulationReport)=gsub('result.','Module_',rownames(AutoRegulationReport))
  
  #y_std<-cbind(BetaY_all[4,])
  #y_std<-cbind(BetaY_all[3,])
  
  
  # calculating the error
  error = y_all - ((Beta %*% RegulatorData) + intercept)
  SSres<-apply(error, 1, var)
  SStot<-apply(y_all, 1, var)
  print(1-SSres/SStot)
  result <- list(y_std = y_std, Beta = Beta,error = error, centroids=(Beta %*% RegulatorData + intercept))
  return(result)
}


